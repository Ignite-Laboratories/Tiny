package tiny

import (
	"fmt"
	"math"
)

// Emit expresses the underlying bits of the provided binary operands according to the logical expression generated by Bits.
//
// For an "unlimited" maximum, please pass in Unlimited.
func Emit[T binary](expr Expression, maximum uint, operands ...T) []Bit {
	// Do nothing if there is no binary information to emit
	totalWidth := GetBitWidth(operands...)
	if totalWidth == 0 || maximum == 0 {
		return make([]Bit, 0)
	}

	if len(*expr._positions) > 0 && (expr._low != nil || expr._high != nil) {
		panic("cannot search for an explicit position inside of a range - you can perform that operation with compound emit operations")
	}

	// Set our cursor limit
	if expr._positions != nil {
		// We are performing point selection
		expr._limit += uint(len(*expr._positions))
	} else {
		// We are performing range selection
		expr._limit = totalWidth

		// Set the boundaries and limit value according to the expression
		if expr._low != nil {
			expr._limit -= uint(*expr._low)

			if expr._high != nil {
				expr._limit = *expr._high - *expr._low
			} else {
				// If no high boundary, set it to the last index of the operands
				last := uint(int(totalWidth) - 1)
				expr._high = &last
			}
		} else {
			zero := uint(0)
			expr._low = &zero
		}
	}

	// Set the limit to the minimum of the provided maximum and the expressed range
	expr._limit = uint(math.Min(float64(expr._limit), float64(maximum)))

	// Calculate the last bit position of the operands, if requested
	if expr._last != nil {
		added := append(*expr._positions, totalWidth-1)
		expr._positions = &added

		expr._last = nil
	}

	// Check if the data should be reversed at this point in recursion
	if expr._reverse != nil && *expr._reverse {
		// If so...put your thing down, flip it, and reverse it
		reversed := make([]T, len(operands))
		limit := len(operands) - 1

		for i := limit; i >= 0; i-- {
			switch operand := any(operands[i]).(type) {
			case Measurement:
				reversed[limit-i] = any(operand.Reverse()).(T)
			case Phrase:
				reversed[limit-i] = any(operand.Reverse()).(T)
			case []byte:
				r := make([]byte, len(operand))
				for ii := len(operand) - 1; ii >= 0; ii-- {
					r[limit-ii] = ReverseByte(operand[ii])
				}
				reversed[limit-i] = any(r).(T)
			case []Bit:
				r := make([]Bit, len(operand))
				for ii := len(operand) - 1; ii >= 0; ii-- {
					r[limit-ii] = operand[ii]
				}
				reversed[limit-i] = any(r).(T)
			case byte:
				reversed[limit-i] = any(ReverseByte(operand)).(T)
			}
		}

		operands = reversed

		expr._reverse = nil
	}

	// Switch on matrix or linear logic based upon the presence of an artifact function
	if expr._artifact != nil {
		// Matrix logic - Performs logic at the phrase level while emitting out the underlying bits
		yield, _ := matrixLogic(0, expr, operands...)
		return yield
	}
	// Linear logic - Recurses to the bit level before performing logic
	yield, _ := linearLogic(0, expr, operands...)
	return yield
}

func linearLogic[T binary](cursor uint, expr Expression, operands ...T) ([]Bit, uint) {
	// Pre-allocate a reasonable chunk of memory
	yield := make([]Bit, 0, 1<<10)

	// Walk through the current operands one at a time
	for _, raw := range operands {
		cycleBits := make([]Bit, 0, 1<<10)

		// Decompose them through recursion
		switch operand := any(raw).(type) {
		case Phrase:
			// Phrases recurse into their respective measurements
			if operand.BitWidth() == 0 {
				continue
			}

			var bits []Bit
			bits, cursor = linearLogic(cursor, expr, operand.Data...)
			cycleBits = append(cycleBits, bits...)
		case Measurement:
			// Measurements recurse into their respective bytes and then their bits
			if operand.BitWidth() == 0 {
				continue
			}

			var bits []Bit

			bits, cursor = linearLogic(cursor, expr, operand.Bytes...)
			cycleBits = append(cycleBits, bits...)

			bits, cursor = linearLogic(cursor, expr, operand.Bits...)
			cycleBits = append(cycleBits, bits...)
		case []byte:
			// Byte slices break into their individual bytes
			if len(operand) <= 0 {
				continue
			}

			var bits []Bit
			bits, cursor = linearLogic(cursor, expr, operand...)
			cycleBits = append(cycleBits, bits...)
		case byte:
			// Bytes break into their individual bits
			bits := make([]Bit, 8)
			for i := 7; i >= 0; i-- {
				bits[i] = Bit((operand >> i) & 1)
			}
			bits, cursor = linearLogic(cursor, expr, bits...)
			cycleBits = append(cycleBits, bits...)
		case []Bit:
			// Bit slices step the cursor across the bits and select out data
			if len(operand) <= 0 {
				continue
			}

			// Walk through the bits
			for _, bit := range operand {
				if len(*expr._positions) > 0 {
					// We are performing explicit position selection
					for _, pos := range *expr._positions {
						if pos == cursor {
							cycleBits = append(cycleBits, bit)
						}
					}
				} else {
					// We are performing ranged selection
					if cursor >= *expr._low && cursor < *expr._high {
						cycleBits = append(cycleBits, bit)
					}
				}

				// Increment the cursor's current bit position in the source information
				cursor++
			}
		default:
			panic(fmt.Errorf("invalid binary type: %T", operand))
		}

		// Yield the found bits
		yield = append(yield, cycleBits...)

		// Bailout when the pre-calculated limit has been met
		if len(yield) >= int(expr._limit) {
			return yield[:int(expr._limit)], cursor
		}
	}
	return yield, cursor
}

func matrixLogic[T binary](cursor uint, expr Expression, operands ...T) ([]Bit, uint) {
	// TODO: start sub-expressions to grab bits and build a matrix for computation

	//if expr._matrix != nil && *expr._matrix {
	//	/**
	//	Matrix Logic
	//	*/
	//
	//	if expr._matrixLogic == nil {
	//		panic("matrix expressions require a logic function")
	//	}
	//
	//	calculate := *expr._matrixLogic
	//
	//	if expr._alignment == nil {
	//		align := PadLeftSideWithZeros
	//		expr._alignment = &align
	//	}
	//
	//	longest := GetWidestOperand(data...)
	//
	//	if longest <= 0 {
	//		return yield, 0
	//	}
	//
	//	subExpr := expr
	//	subExpr._matrix = &False
	//
	//	// The underlying table is ordered [Col][Row]Bit
	//	table := make([][]Bit, longest)
	//	for i, raw := range data {
	//		data[i] = AlignOperand(raw, longest, *expr._alignment)
	//		table[i], _ = Emit[T](subExpr, raw)
	//	}
	//
	//	// TODO: We can't walk using longest because longest will grow as we carry - instead we need to just walk until we are out of bits to walk and pass the walk count to the matrix func
	//
	//	for i := 0; i < longest; i++ {
	//		colId := i
	//		if reverse {
	//			colId = longest - i - 1
	//		}
	//
	//		column := make([]Bit, len(table))
	//		for rowId, row := range table {
	//			column[rowId] = row[colId]
	//		}
	//		calculated, overflow := calculate(colId, column...)
	//
	//		// TODO: Insert the overflow binary value BELOW the upcoming columns in the direction of calculation
	//
	//		if reverse {
	//			yield = append(yield, calculated)
	//		} else {
	//			yield = append([]Bit{b}, yield...)
	//		}
	//	}
	//
	//	linear := make([]Bit, 0, len(matrix)*longest)
	//	for _, element := range matrix {
	//		linear = append(linear, element...)
	//	}
	//
	//	yield = linear
	//	count = uint(longest) // TODO: Alignment all the operands and set this to the number of returned operands
	//} else {
	return nil, -1
}
